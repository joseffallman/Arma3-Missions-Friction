/*
 * Name:	ClientEventReciever
 * Date:	2019-01-31
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Static class that handles all custom events sent from other machines.
 *
 * Remarks:
 * The idea here is to avoid being specific about what is supposed to happen on the target machine. The name of each 
 * method should start with "On" to reflect an event that "happens" on the machine firing it. E.g. do not name a method like 
 * "ThrowPlayerInTeamKillPrison". Instead name it after the reason, so better use "OnPlayerKilled" with killer and
 * victim as parameters. This way
 * the server do not care about what happens on the client, it simply reports what happens on the server. And also,
 * the client may want to do more than one thing with this event. E.g. lowering the killers rating. This way you do not 
 * couple the server and client together, so that the server can focus only on server stuff and the client only on client
 * stuff.
 *
 * Do not perform logic in this class - (or at least not advanced logic). Instead route the event message action to
 * the class or classes meant to handle the logic needed for each event message respectively.
 */

using Mission.Common;
using Mission.Common.Statics;
using Mission.Client;
using Mission.Communication;

namespace Mission.Client.Statics
{
	public class ClientEventReciever
	{
		// Called when the mission engine on the server starts.
		public static method OnMissionStart()
		{
		
		};
	
		// Called each time a second passes in the mission.
		// _missionTimeRemaining (Scalar): The remaining time until the mission ends in seconds.
		public static method OnMissionTimeTick("_missionTimeRemaining" as Scalar)
		{
			hint ("Mission ends in " + (str _missionTimeRemaining) + " minutes.");
		};
		
		public static method OnMissionSetup("_missionMarkersInfo" as MissionMarkersInfo)
		{
			private ["_markerInfos" as Array /* of String */];
			
			cutText ["", "BLACK OUT", 1];
				
			// Update the markers
			
			[_missionMarkersInfo] call ClientObjects.MapMarkerHandler.UpdateMarkers;
			
			if (player == leader group player) then
			{
				// If no insertion markers are specified, perform insertion immediately
				_markerInfos = [playerSide] call _missionMarkersInfo.GetStartMarkersBySide;
				
				if (count _markerInfos == 0) then {
					["ServerEventReciever.OnPlayerPerformingInsertion", [playerSide, getPos player]] call Remote.Invoke;
				};
			};
		};
		
		public static method OnMissionBriefing("_missionBriefing" as MissionBriefing)
		{
			private ["_briefingService" as MissionBriefingService];
			
			_briefingService = [_missionBriefing, ClientObjects.BriefingHandler, ClientObjects.TaskHandler, false] new MissionBriefingService;
			
			call _briefingService.RunAsync;
		};
		
		private static method Boolean AnyMemberIsPlayer("_group" as Group)
		{
			{
				if (isPlayer _x) then {
					return true;
				};
			} foreach units _group;
			
			return false;
		};
		
		public static method OnInsertGroup("_group" as Group, "_position" as Array)
		{
			private ["_teleporter" as TeleportService];
			
			if (playerSide == side _group) then
			{
				[_position] call ClientObjects.MapMarkerHandler.AddExtractionMarker;
			
				_teleporter = [_position] new TeleportService;
				call _teleporter.RunAsync;
			};
			
			// Hide insertion menu option
			call TvtcfMenuHandler.UpdateVisibleOptions;
		};
		
		public static method OnMissionEnded("_missionResult" as MissionResult, "_accumulatedScoreWest" as Scalar, "_accumulatedScoreEast" as Scalar)
		{
			private ["_teleporter" as TeleportService, "_resultInfo" as MissionResultInfo];
			
			// "Resurrect" player
			ClientState.IsAlive = true;
			call ClientObjects.CameraHandler.ResetPlayerCamera;
			
			// Reset loadout
			
			if (playerSide == west) then {
				player setUnitLoadout "B_Soldier_F";
			}
			else {
				player setUnitLoadout "O_Soldier_F";
			};
			
			// Show mission result
			
			if (!(player diarySubjectExists "Results")) then {
				player createDiarySubject ["Results", "Mission Results"];
			};
			
			_resultInfo = [playerSide] call _missionResult.GetResultInfo;
			
			private _diaryText = _missionResult.MissionName + "<br />";
			_diaryText = _diaryText + "<br />" + _resultInfo.PrimaryObjectiveName + ": ";
			_diaryText = _diaryText + ([_resultInfo.PrimaryObjectiveState] call ObjectiveStateMeta.ToLang);
			
			if (_resultInfo.SecondaryObjectiveName != "") then
			{
				_diaryText = _diaryText + "<br />" + _resultInfo.SecondaryObjectiveName + ": ";
				_diaryText = _diaryText + ([_resultInfo.SecondaryObjectiveState] call ObjectiveStateMeta.ToLang);
			};
			
			if (_resultInfo.UsingReturnObjective) then
			{
				_diaryText = _diaryText + "<br />Return to insertion point: ";
				_diaryText = _diaryText + ([_resultInfo.ReturnObjectiveState] call ObjectiveStateMeta.ToLang);
			};
			
			_diaryText = _diaryText + "<br />Men lost: " + str (_resultInfo.MenAtStart - _resultInfo.MenAtEnd);
			_diaryText = _diaryText + "<br /><br />Mission score: " + str _resultInfo.Score;
			
			_diaryText = _diaryText + "<br /><br />Total score";
			_diaryText = _diaryText + "<br />West: " + str _accumulatedScoreWest + ". East: " + str _accumulatedScoreEast + ".";

			player createDiaryRecord ["Results", [_missionResult.MissionName, _diaryText]];

			// Teleport to base (if not already there)
			
			private _baseMarkerName = [playerSide, BaseMarker.Respawn] call CommonObjects.BaseMarkersConfig.GetMarkerName;
			
			if (player distance getMarkerPos _baseMarkerName > 50) then {
				_teleporter = [getMarkerPos _baseMarkerName] new TeleportService;
				call _teleporter.RunAsync;
			};
			
			// Show insertion menu option
			call TvtcfMenuHandler.UpdateVisibleOptions;
			
			// Delete tasks
			call ClientObjects.TaskHandler.DeleteAllTasks;
		};
		
		public static method OnTaskStateChanged("_side" as Side, "_objectivePrio" as ObjectivePrio, "_objectiveState" as ObjectiveState)
		{
			private ["_teleporter" as TeleportService];
			
			if (_side == playerSide) then
			{
				[_objectivePrio, _objectiveState] call ClientObjects.TaskHandler.SetTaskState;
				
				if (_objectivePrio == ObjectivePrio.Return && _objectiveState == ObjectiveState.Succeeded) then
				{
					private _baseMarkerName = [playerSide, BaseMarker.Respawn] call CommonObjects.BaseMarkersConfig.GetMarkerName;
					
					_teleporter = [getMarkerPos _baseMarkerName] new TeleportService;
					
					[_teleporter] spawn {
						params ["_teleporter" as TeleportService];
						
						sleep 5;
						call _teleporter.RunAsync;
					};
				};
			};
		};
		
		public static method OnCampaignEnded("_westAccumulatedScore" as Scalar, "_eastAccumulatedScore" as Scalar)
		{
			if (playerSide == west) then {
				[_westAccumulatedScore >= _eastAccumulatedScore] call ClientObjects.MissionEndHandler.EndGame;
			}
			else {
				[_eastAccumulatedScore >= _westAccumulatedScore] call ClientObjects.MissionEndHandler.EndGame;
			};
		};
		
		public static method OnUnitKilled("_playerUid" as String, "_unit" as Object, "_killer" as Object)
		{
			if (_playerUid != getPlayerUID player) then {
				call ClientObjects.CameraHandler.SetDeathCamera;
			};
		};
		
		public static method OnShowNotification("_side" as Side, "_text" as String)
		{
			if (_side == playerSide) then {
				[_text] call ClientObjects.TaskHandler.ShowNotification;
			};
		};
		
		public static method OnAddAction("_serverActionId" as Scalar, "_object" as Object, "_title" as String, "_side" as Side)
		{
			if (_side == playerSide) then {
				[_serverActionId, _object, _title] call ClientObjects.ClientActionHandler.AddAction;
			};
		};
		
		public static method OnDeleteActions("_actionIds" as Array)
		{
			[_actionIds] call ClientObjects.ClientActionHandler.DeleteActions;
		};
	};
};
